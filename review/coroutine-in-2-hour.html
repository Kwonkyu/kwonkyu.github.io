<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>2시간으로 끝내는 코루틴</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 90%;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
	margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-default_background {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-transparentGray { background-color: rgba(227, 226, 224, 0); }
.select-value-color-translucentGray { background-color: rgba(0, 0, 0, 0.06); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="7132faaf-2cf8-473e-acdc-fb07dff9837a" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">✅</span></div><h1 class="page-title">2시간으로 끝내는 코루틴</h1><p class="page-description"></p></header><div class="page-body"><ul id="f614ed25-19cc-4b78-b74a-7aecc0f5808e" class="toggle"><li><details open=""><summary>코루틴의 정의</summary><p id="20523667-9532-4954-9705-8e428ccf4a42" class="">코루틴co-routine. 협력하는 루틴(함수). 일반적인 루틴, 함수 호출은 호출자가 함수를 호출하면 해당 함수로 진입하고 루틴 코드를 실행한 후 종료해서 다시 호출자로 돌아오는 과정을 거침. 이 때 루틴은 실행한 후 종료된다면 해당 루틴의 내부(선언된 필드 등)에는 접근할 수 없는게 일반적인 프로그래밍 패러다임.</p><ol type="1" id="2b161b94-49e3-418b-82a4-3f66546b7231" class="numbered-list" start="1"><li>즉 해당 루틴으로 진입하려면 해당 루틴을 호출하는 것이 유일한 진입점이 되며</li></ol><ol type="1" id="db4ea03c-ffc5-427c-9b40-ff5bf14ee319" class="numbered-list" start="2"><li>루틴이 종료되면 해당 루틴에서 사용했던 정보들이 초기화된다.</li></ol><p id="2df9adc1-b820-46e9-a6f0-2891bff23ca0" class="">하지만 코루틴에서는 이거와 다르게 루틴에서 벗어나도 그 정보를 마치 pcb?처럼 유지할 수 있는 기술이 있나봄. 즉 루틴이 완전히 끝나기 전에 어디 다른걸 실행하다가 올 수 있다는 것.</p></details></li></ul><ul id="8bc46b82-1158-4177-b65b-a2874268767d" class="toggle"><li><details open=""><summary>코루틴 빌더</summary><h2 id="be45a3ce-3abd-41e2-9851-04f89bb6103b" class="">runBlocking</h2><p id="5d4dfbe6-2404-4ff5-852a-f16113abc607" class="">그러면 이 ‘일반적인 루틴’에서 코루틴으로 진입하려면 어떻게 해야 할까? 이 때는 <code>runBlocking</code> 이라는 함수로 진입할 수 있다. 이런 애들을 코루틴 빌더(coroutine builder)라고 한다.</p><blockquote id="195fe521-50fe-4fa3-9c13-a093b2e72f12" class="">It is designed to bridge regular blocking code to libraries that are written in suspending style, to be used in main functions and in tests.</blockquote><p id="a4818a2a-93fa-4f06-a1e8-161dbc3f98c3" class="">이걸 사용하는 순간 코루틴의 세계를 정의하는 것이고 그 안에서 실행되는 코드들을 ‘코루틴’이라고 부를 수 있는 것이다. 그래서 얘는 코루틴 안에서 호출하지 말라고 명시되어 있음. <code>fun main</code> 같은 역할인가?</p><h2 id="f2349beb-2818-4bd3-8e80-332204c9b5ab" class="">launch</h2><p id="126e818d-09c5-468e-b99a-ee40de6d160d" class="">코루틴 안에서 다른 코루틴을 호출하려면 <code>launch</code> 로 새로운 블록을 만들어서 호출할 수 있다. 얘는 코루틴을 정의하는 느낌이라 바로 해당 서브루틴을 실행하지 않는다. 즉 아래 설명처럼 현재 스레드를 block하지 않는다.</p><blockquote id="1296ea70-50a9-43f8-87f1-d3970a1a786a" class="">Launches a new coroutine without blocking the current thread and returns a reference to the coroutine as a Job.<br/>…<br/>By default, the coroutine is immediately scheduled for execution<br/></blockquote><p id="ec897b78-9a40-4b0c-bfa9-b21aa52a16e1" class="">작업을 실행할 수 있도록 스케줄링하는 것. 그래서 바로 실행되도록 스케줄링할 수도 있고 좀 레이지하게 나중에 시작시키면 실행되도록(정확히는 실행가능하도록) 할 수도 있음. <code>launch</code> 함수 반환값이 그 람다 표현식 내 작업을 참조하는 객체를 반환하기 때문에 그걸 조정해서 할 수 있다.</p><p id="cc5c314f-69cd-49f9-a10e-60b4d11016ed" class="">서브루틴을 이 블록 안에 넣지 않고 호출하면 일반 함수를 호출하는 것과 동일하게 동작한다. 즉 그냥 루틴이 됨.</p><h2 id="ada5b7c0-d029-4aca-b0ec-87ef672cc834" class="">async</h2><p id="e83eb016-0162-4033-a258-02eb6438e9a3" class="">launch와 비슷하지만 그 결과를 반환값으로 돌려줄 수 있다. <code>launch</code> 가 코루틴 자체의 Job을 돌려주던 것에 비해 활용하기가 편함. 비동기 처리기 때문에 바로 반환값을 주는 건 아니고 Deferred라는 클래스로 래핑되서 반환된다. 기본값은 얘를 await해서 가져올 수 있는데 마치 자바스크립트 쪽에서 async, await 하는거랑 비슷. 콜백 지옥을 없애고 동기식으로 코드를 작성할 수 있고… 같은 것.</p><blockquote id="f1af4447-c6fd-431b-9dcb-1ac874b7b7b2" class="">By default, the coroutine is immediately scheduled for execution. Other options can be specified via start parameter.</blockquote><p id="ca07f8a4-1156-4dd6-b6fa-7d0c10bf25df" class="">이 코루틴도 생성되자마자 바로 실행되도록 스케줄링된다. 물론 start 옵션으로 LAZY하게 설정하는 것이 가능해서 생성 후 <code>join</code>, <code>await</code> 등 묵시적으로 또는 <code>start</code> 로 명시적으로 실행시킬 수도 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="961ac0c5-38a0-49dd-b652-534ddbd1269c" class="code"><code class="language-Kotlin">val sum1 = async(start = CoroutineStart.LAZY) {
    println(&quot;calculating sum1...&quot;)
    delay(1000)
    1 + 2
} // sum1 작업을 정의하긴 했으나 아직 실행되지 않았다.
val sum2 = async(start = CoroutineStart.LAZY) {
    println(&quot;calculating sum2...&quot;)
    delay(2000)
    100 + 200
} // sum2 작업을 정의하긴 했으나 아직 실행되지 않았다.

println(&quot;getting sum1 result... &quot;)
val sum1Result = sum1.await() // &lt;&lt; 값을 얻어와야 하므로 묵시적으로 sum1 코루틴을 실행.
println(&quot;sum1: $sum1Result&quot;)
println(&quot;getting sum2 result... &quot;)
val sum2Result = sum2.await() // &lt;&lt; 값을 얻어와야 하므로 묵시적으로 sum2 코루틴을 실행.
println(&quot;sum2: $sum2Result&quot;)</code></pre><p id="dcfeafa3-1e52-4873-a6c3-260b96d0a489" class="">위의 실행 결과는 다음과 같다.</p><p id="fca85704-9a68-4896-bc25-546332826268" class="">[17:31:35.713] getting sum1 result...<br/>[17:31:35.720] calculating sum1...<br/>[17:31:36.737] sum1: 3<br/></p><ul id="79fc90a9-f159-4253-9cad-6565593baf3c" class="bulleted-list"><li style="list-style-type:disc">여기까지는 sum1Result 변수에 값을 담기 위해 <code>sum1.await()</code> 함수를 호출해서 실행.</li></ul><ul id="3f18a672-134f-4e7e-b946-7c550674046d" class="bulleted-list"><li style="list-style-type:disc">sum1 작업 내부에서 볼 수 있듯이 1000ms를 대기하고 결과를 얻을 수 있었다.  </li></ul><p id="7395d95e-6c42-4f32-8f21-d222f4196bfb" class="">[17:31:36.737] getting sum2 result...<br/>[17:31:36.738] calculating sum2...<br/>[17:31:38.742] sum2: 300<br/></p><ul id="9088fd99-da36-45ae-89c9-d18116d17beb" class="bulleted-list"><li style="list-style-type:disc">sum2Result 변수에 값을 담기 위해 <code>sum2.await()</code> 함수를 호출해서 실행했고 비슷하게 2000ms를 대기한 후 결과를 얻을 수 있었다.</li></ul><p id="2ba699fd-ef5f-42ab-b8b9-55a781e0dd79" class="">최종적으로 보면 1초, 2초의 작업 시간을 거쳐 3초를 기다려야 했으며 동기적으로 실행했기 때문에 코루틴을 쓰는 효과를 전혀 보지 못했다. 그러면 LAZY하지 않고 바로 실행되도록 하면 어떨까?</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b1de142f-17a7-47af-b25b-fdd2f94f2906" class="code"><code class="language-Kotlin">val sum1 = async {
    println(&quot;calculating sum1...&quot;)
    delay(1000)
    1 + 2
} // 생성되는 즉시 실행된다. 물론 내부적으로 뭔가 돌아가기 때문에 약간의 딜레이는 있겠지만..
val sum2 = async {
    println(&quot;calculating sum2...&quot;)
    delay(2000)
    100 + 200
}

delay(1000) // async 작업들이 생성 즉시 실행된다는 것을 보이기 위해 main을 delay.
println(&quot;ayo sum1 and sum2 done?&quot;)
val sum1Result = sum1.await() // 1000ms를 기다렸으니 sum1은 바로 얻을 수 있을 것이다.
println(&quot;sum1: $sum1Result&quot;)
println(&quot;getting sum2 result... &quot;)
val sum2Result = sum2.await() // sum2는 2000ms기 때문에 1000ms를 더 기다려야 한다.
println(&quot;sum2: $sum2Result&quot;)</code></pre><p id="79c149cb-4c43-49cb-b88a-47d6201f1420" class="">위의 실행 결과는 다음과 같다.</p><p id="8dc8c439-6fb0-483f-93be-ab69bfd74469" class="">[17:44:15.521] calculating sum1...<br/>[17:44:15.525] calculating sum2...<br/></p><ul id="1908d295-10ae-4e49-b812-30f169b79cbf" class="bulleted-list"><li style="list-style-type:disc">이후 main에 1000ms간 delay가 있었기 때문에 15초에서 16초까지의 갭이 있다.</li></ul><p id="8e53097d-0d65-439c-9a8b-dc36721f986c" class="">[17:44:16.522] ayo sum1 and sum2 done?<br/>[17:44:16.534] sum1: 3<br/></p><ul id="0fb23510-922a-4d71-a195-a80cb0fa6572" class="bulleted-list"><li style="list-style-type:disc">1000ms 동안 sum1 작업은 완료됐을 것이니 결과는 <code>await</code> 으로 호출하는 즉시 받을 수 있다.</li></ul><p id="81268030-71a4-40a1-b07f-5ddb856aa782" class="">[17:44:16.534] getting sum2 result...<br/>[17:44:17.532] sum2: 300<br/></p><ul id="bbd04e9a-dc13-4013-b730-4068b015de20" class="bulleted-list"><li style="list-style-type:disc">그에 반해 sum2 작업은 2000ms가 걸리기 때문에 1초를 더 기다려서 17초가 되야 받을 수 있다.</li></ul><blockquote id="b7836e1f-8069-49e3-bf10-a1917bb99ca2" class="">it cancels the parent job (or outer scope) on failure to enforce structured concurrency paradigm.</blockquote><p id="b00d10cb-832b-4a19-812b-bf7e1e046640" class="">음.. 이거는 뭔가 알아둬야 할 내용인듯?</p><p id="08298272-00a4-4457-b13f-7d2e97d83731" class="">
</p></details></li></ul><ul id="b11f9748-fc34-4c07-9a48-16de1872f8e0" class="toggle"><li><details open=""><summary>코-오퍼레이션</summary><h2 id="86fce0c2-dc5f-4580-8122-ecaf02e7252a" class="">yield</h2><blockquote id="241f9dcb-8dd0-4e82-bf07-2bb24122b913" class="">Yields the thread (or thread pool) of the current coroutine dispatcher to other coroutines on the same dispatcher to run if possible.</blockquote><p id="0a351aa0-78fb-47a5-b562-8a8d6152822b" class="">코루틴이 co-operation하기 위해서는 다른 곳이랑 협력해야 한다. 자기 혼자만 실행하고 런치면 안되니까.. 그래서 <code>yield</code> 라는 함수를 이용하여 양보하는 시점을 지정할 수 있는듯.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c027bb3a-69a4-47d7-89bd-9eba3dd3ffa7" class="code"><code class="language-Kotlin">fun main() {
    runBlocking {
        println(&quot;Hello, World!&quot;)
        println(&quot;pre-subroutine 1&quot;)
        launch { // 1. subRoutine1 스케줄.
            subRoutine1() // &lt;&lt; 람다 표현식 내부에 정의하는 것이기 때문에 실행 호출이 아님
        }
        yield() // 2. 현재 루틴에서 다른 루틴으로 실행 양보.
        println(&quot;post-subroutine 1&quot;) // 4. 실행 종료 후 코루틴 설정에 따라 남은 작업 복귀.
    }
}

suspend fun subRoutine1() {
    println(&quot;Subroutine 1&quot;)
    yield() // 3. 현재 루틴에서 다른 루틴으로 실행 양보.
    val localVal1 = 1
    val localVal2 = 2
    println(&quot;Subroutine 1: localVal1 + localVal2: ${localVal1 + localVal2}&quot;)
    // 5. 모든 루틴이 종료된 후 프로그램 exit.
}</code></pre><p id="9afa66a9-4ea4-4ca8-a66b-2a92e20e8efb" class="">그래서 다음처럼 출력된다.</p><p id="917ddd2a-4275-494d-979e-429e9efd1ab7" class="">Hello, World!<br/>pre-subroutine 1<br/>Subroutine 1<br/>post-subroutine 1<br/>Subroutine 1: localVal1 + localVal2: 3<br/></p><p id="b228062a-59e4-4c56-83d1-e0b5367edfe2" class="">여기서 알 수 있는 것은 루틴과는 다르게 코루틴에서는 실행 지점이 특정 루틴 밖으로 나가도 함수의 실행 컨텍스트가 사라지지 않았다는 것이다. main에서 runBlocking으로 시작 후 yield, subRoutine1로 진입한 후 다시 yield해서 main으로 돌아갔을 때, 로컬 지역번수인 localVal1, localVal2가 사라지지 않았다. 다시 실행 지점이 subRoutine1로 돌아왔을 때 localVal1 + localVal2를 정상적으로 출력하는 것을 볼 수 있다.</p><h2 id="84007cec-631a-44f0-abb7-831d4d559721" class="">delay</h2><p id="4b9abd7e-bbc8-45e5-9b01-a40a66deda78" class="">일정 시간동안 스레드를 양보하는 메서드. yield는 양보하더라도 만약 다른 코루틴들이 다 양보해서 스레드가 남는다면 다시 작업을 시작할 수 있지만 delay는 일정 시간동안 아예 동작하지 않는다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2495242d-f384-4bbc-8326-27e276b752d6" class="code"><code class="language-Kotlin">val job1 = launch { // 실제로 뭔가를 수행하는 작업 1
    println(&quot;job1 entry point&quot;)
    (1..5).forEach {
        println(&quot;job1 doing its job... #$it&quot;)
        delay(50)
        println(&quot;#$it done.&quot;)
    }
    println(&quot;job1 terminated&quot;)
}
val job1StartTime = Instant.now()

launch { // 작업 1이 너무 오래 걸릴경우 취소시키는 작업
    while(Instant.now().minusMillis(100).isBefore(job1StartTime)) {
        println(&quot;waiting for job1 to finish...&quot;)
        delay(10)
    }

    println(&quot;job1 is still running. Cancelling...&quot;)
    job1.cancel()
}

val background = launch {
    while(true) { // 모든 코루틴이 양보했을 때 백그라운드에서 도는 작업
        println(&quot;background job entry point&quot;)
        delay(5)
    }
}

yield() // 메인 스레드에서 작업 1로 넘김.
job1.join() // 작업 1의 종료를 기다림.
background.cancel()</code></pre><p id="61d45df8-85f6-4930-bcbe-ed6893775123" class="">출력 결과는 다음과 같다.<br/>[13:12:30.448] job1 entry point<br/>[13:12:30.456] job1 doing its job... #1<br/></p><ul id="e3327733-6c10-4944-8afd-18f5b780301c" class="bulleted-list"><li style="list-style-type:disc">job1이 작업을 수행하고 50ms동안 delay한다. 그러므로 이 코루틴은 50ms동안 스레드를 받지 않는다.</li></ul><p id="ebaef008-d770-4a98-9cc9-f109932681aa" class="">[13:12:30.459] waiting for job1 to finish...</p><ul id="cf888aeb-6258-424b-b9f1-117f47bdeaeb" class="bulleted-list"><li style="list-style-type:disc">작업1이 100ms가 넘으면 취소시키는 작업이 while 문을 돌면서 10ms씩 delay하고 있다.</li></ul><ul id="360423f8-b98b-465f-b5fe-c968a2b93938" class="bulleted-list"><li style="list-style-type:disc">그러므로 이 작업 역시 10ms동안 스레드를 받지 않고… 그러면 누가 남았는가?</li></ul><p id="6477c96c-8d47-414b-b397-c420340bb803" class="">[13:12:30.459] background job entry point</p><ul id="f6480478-f3b2-4e75-9b39-6581010c307f" class="bulleted-list"><li style="list-style-type:disc">마지막으로 남은 background 작업이 스레드를 가져가서 작업한다. 이 코루틴도 5ms동안 delay한다.</li></ul><ul id="20de3e17-2e1e-4dfb-8fc6-08e6fbecf2c1" class="bulleted-list"><li style="list-style-type:disc">그러나 job1은 이미 50ms동안, 취소작업은 10ms동안 코루틴을 delay했기 때문에 아무도 스레드를 갖지 않는다.</li></ul><ul id="deb8f42c-99b3-4eed-8687-0b5d08366a4c" class="bulleted-list"><li style="list-style-type:disc">그러나 이 코루틴은 5ms로 짧은 시간동안 delay하기 때문에 가장 짧은 대기작업인 위의 취소 작업이 10ms동안 대기하는 동안 두 번 정도 돌 것이라 생각할 수 있다.</li></ul><p id="bc469637-5d1d-44e9-8ada-dd4a9b911b40" class="">[13:12:30.465] background job entry point</p><ul id="390ad073-8c1b-48ea-a60b-7c4bb853bb9b" class="bulleted-list"><li style="list-style-type:disc">이 로그에서 볼 수 있듯이 459에서 465로 약 5ms가 지나서 한번 더 호출된 것을 볼 수 있다.</li></ul><p id="98cf884e-8ccf-4339-bfe0-ab3385dacb82" class="">[13:12:30.470] waiting for job1 to finish...</p><ul id="cdf386a2-355a-434c-9aec-863c2c1310aa" class="bulleted-list"><li style="list-style-type:disc">459에서 470으로 약 10ms가 지났기 때문에 취소작업이 다시 한번 스레드를 받아서 작업한다.</li></ul><ul id="89b00747-95da-4a40-9935-e9c62bee9b69" class="bulleted-list"><li style="list-style-type:disc">그러나 아직 while 문의 조건(작업1의 실행시간이 100ms 이하)을 만족하기 때문에 다시 delay 한다.</li></ul><ul id="8004bab4-0326-4940-806a-471a7b84411e" class="bulleted-list"><li style="list-style-type:disc">이후 이 과정이 아래 로그에서 볼 수 있듯이 세 번 정도 더 반복된다.</li></ul><p id="465bb526-37ba-437f-99f1-903596dae0c4" class="">[13:12:30.470] background job entry point<br/>[13:12:30.476] background job entry point<br/>[13:12:30.480] waiting for job1 to finish...<br/>[13:12:30.481] background job entry point<br/>[13:12:30.487] background job entry point<br/>[13:12:30.491] waiting for job1 to finish...<br/>[13:12:30.493] background job entry point<br/>[13:12:30.499] background job entry point<br/>[13:12:30.502] waiting for job1 to finish...<br/>[13:12:30.505] background job entry point<br/>[13:12:30.509] #1 done.<br/></p><ul id="ee303614-9982-4391-9b1a-37659855e37a" class="bulleted-list"><li style="list-style-type:disc">456에서 509로 약 50ms가 지난 후 작업이 종료되었다. 정확히는 50ms동안 delay하던 것이 끝나고 새로운 작업을 시작할 준비가 되었다.</li></ul><p id="de6015ef-171d-4a0b-ba08-3b00deab8477" class="">[13:12:30.509] job1 doing its job... #2<br/>[13:12:30.510] background job entry point<br/>[13:12:30.512] waiting for job1 to finish...<br/>[13:12:30.515] background job entry point<br/>[13:12:30.522] background job entry point<br/>[13:12:30.523] waiting for job1 to finish...<br/>[13:12:30.528] background job entry point<br/>[13:12:30.534] background job entry point<br/>[13:12:30.534] waiting for job1 to finish...<br/>[13:12:30.540] background job entry point<br/></p><ul id="0ab05f84-7a5f-4230-ad7c-ddc267007f13" class="bulleted-list"><li style="list-style-type:disc">이곳까지는 동일하게 동작하지만 작업을 시작했던 456에서(정확히는 그보다 좀 이른데 작업이 실제로 시작된 시각과 시작시각을 기록한 때가 다르기때문) 점점 100ms 제한이 다다르고 있다.</li></ul><p id="2b991dbf-1c8c-4c3b-ae4f-11e6b26bac9f" class="">[13:12:30.545] job1 is still running. Cancelling...</p><ul id="48db085e-37d0-4c5c-b151-c43fc2d2d829" class="bulleted-list"><li style="list-style-type:disc">약 100ms가 지난 후 작업 1이 너무 오래 돌아가고 있었기 때문에 <code>job1.cancel()</code> 을 호출하여 작업을 취소시켰다.</li></ul><ul id="7e5bfae3-eb56-46e4-a078-e0b0c51bb9d6" class="bulleted-list"><li style="list-style-type:disc">이후 main, runBlocking 코루틴에서는 <code>job1.join()</code> 으로 기다리던 코드를 지나서 백그라운드 작업까지 취소시키고 프로그램을 종료한다.</li></ul><p id="029a8217-595b-4d9a-aeba-ed3b6ef092a9" class="">[13:12:30.546] background job entry point</p><ul id="07dfe491-e7a7-4886-b164-ed94bb35de73" class="bulleted-list"><li style="list-style-type:disc">백그라운드 작업이 운좋게 완전히 취소되기 전에 스레드를 받아서 실행됐기에 출력된 로그다.</li></ul><h2 id="60dbc932-5b2c-4f53-aabd-9faa8bf283fa" class="">join</h2><p id="ebd2f8ef-5db6-4ec5-a8ee-0a26ceb50e7e" class="">위에서 잠깐 썼던 <code>join</code> 은 해당 작업이 끝나기를 기다리는(block) 함수다. 실행되지 않았더라면 실행시키고 그 작업이 성공해서 정상적으로 종료되든 위처럼 취소되서 비정상적으로 종료되든 상관없이 작업이 끝났는지 여부를 기다린다.</p></details></li></ul><ul id="9fc89c1e-07a0-49f0-9777-5e6bcb3b3220" class="toggle"><li><details open=""><summary>스레드랑 비슷한가?</summary><p id="49f1ab2f-d60b-4890-987f-c7e20662885d" class="">프로세스-스레드 관계와는 조금 다른게 스레드는 프로세스 안에서 스레드를 생성해서 관리하고 사용하는 방식이라 둘이 단단히 묶여있는 것에 반해 코루틴은 실행할 때마다 다른 스레드에 배정될 수도 있다. 코루틴 자체는 독립적으로 존재하고 얘네를 양보하고 복귀하고 할 때마다 그냥 스레드가 가져가서 실행시키는 느낌?</p><p id="efc4306e-1d4d-422c-91d7-4bdec2160b21" class="">그래서 뭔가 컨텍스트 스위칭이 일어날 때도 프로세스가 PCB를 통째로 갈아끼우던 것에 비해 코루틴은 CPU 코어가 스레드를 실행시킬 때 한 프로세스 내에서 스레드의 컨텍스트만 교체하면 되기 때문에(힙, 스택 메모리에 이것저것 올리고 내릴 필요가 없음) 비용이 저렴하다.</p><p id="b35af21e-24b6-402c-b0c3-15969a9b5171" class="">스레드는 한번 동작하면 다른 스레드가 인터럽트를 걸어서 동작이 중단될 수 있는 선점형 방식인 반면에 코루틴은 자신이 양보하는 비선점형 방식이다.</p></details></li></ul><ul id="6efa2a92-a0c7-46f4-afb0-cef30ba226ff" class="toggle"><li><details open=""><summary>코루틴의 취소</summary><p id="cbf7c5f1-c210-4506-8b3c-25894e981963" class="">코루틴 작업을 실행 중에 취소할 수도 있고 실행 전에 그냥 취소해버릴 수도 있다. 그러나 어쨌든 뭔가 코루틴은 비 선점형이라고 했으니.. 뭔가 취소하거나 양보를 하고 싶다면 해당 코루틴이 양보하는 코루틴, 즉 내부적으로 양보하는 기능이 있어야 하고 이를 위해서는 <code>kotlinx.coroutines</code> 패키지에 있는 suspend 함수를 이용해야 한다.</p><p id="32c18c51-1de1-4cea-920a-bcf1fda1c060" class="">어려울 것 없이 지금까지 사용하던 delay, yield 등의 함수들이 그에 해당한다. 생각해보면 자신의 스레드를 몇 초 동안(delay) 양보(yield)하는 것이기 때문에 뺏기는 건 아니고 스스로 양보하는 것이라 할 수 있는듯.</p><p id="c18c4c4b-3dd5-4ab7-8510-354b312bb7c9" class="">만약 양보를 안 하고 계속 작업한다면? 밖에서 취소시키든 말든 그냥 작업을 끝내고 스레드를 돌려준다. 그 상태가 되면 이미 취소의 의미가 없어졌을 것. 그렇지만 delay, yield 등을 이용하여 양보를 할 수 없는 경우 코루틴 내부의 <code>isActive</code> 같은 메서드를 통해 자신의 상태를 확인할 수 있다.</p><blockquote id="6a458192-f6f1-4721-bb81-ed9503ee533c" class="">Returns true when the current Job is still active (has not completed and was not cancelled yet).<br/>Check this property in long-running computation loops to support cancellation:<br/></blockquote><p id="d4982546-ae76-4fdc-8374-e830ceafabaf" class="">이러고 나서 수동으로 CancellationException 예외를 던져주면 해당 코루틴이 취소 처리가 된다. 사실 위의 suspend 함수 애들도 내부적으로 이 예외를 던지면서 동작하고 있었다고 함. 그렇지만 코루틴은 이 예외를 진짜 예외로 던지지 않고 취소로 취급하고 있는 느낌.</p><p id="1b8c463d-d90e-4edf-a966-9d1a58a5147f" class="">이걸 테스트하는 코드는 생긴게 조금 다른게 한 스레드가 양보를 안하기 때문에 이전처럼 작성하면 안 된다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4c4f64c4-8db9-4ce1-94de-67c19cf02a8a" class="code"><code class="language-Kotlin">var job1StartTime: Instant = Instant.now()
val job1 = launch {
    job1StartTime = Instant.now()
    println(&quot;yieldingJob1 entry point&quot;)
    (1..5).forEach {
        println(&quot;yieldingJob1 doing its job... #$it&quot;)
        val currentTaskStartTime = Instant.now()
        while(Instant.now().minusMillis(50).isBefore(currentTaskStartTime)) {
            // blocks this thread.
        }
        println(&quot;yieldingJob1 #$it done.&quot;)
    }
}

val job1CancellingJob = launch {
    while (Instant.now().minusMillis(100).isBefore(job1StartTime)) {
        // waiting for job1 to timeout.
    }
    println(&quot;job1 timeout. Cancelling...&quot;)
    job1.cancel()
}</code></pre><p id="a0bad96d-16b6-42de-8057-d3af985a9956" class="">위 코드는 잘 될거같은데 안된다. 왜냐면 job1이 스레드를 한번 물고 안 놔주기 때문에(yield, delay 등 suspend 함수 호출이 없다) <code>job1CancellingJob</code> 이 <code>job1.cancel()</code> 을 할 새가 없기 때문. 거기다 둘 다 양보를 안하기 때문에 <code>job1CancellingJob</code> 은 <code>job1</code> 이 한 번 양보해주면 아직 다시 돌려주지 않고 while 문을 돌면서 종료를 기다리기 때문에 실제로 임계 시간이 지나지 않았더라도 작업을 계속할 수 없어 역시 문제가 있다.</p><p id="bcf39331-82e5-4513-a099-0f74ba78fd52" class="">그래서 수정을 한다면 아마 아래처럼 <code>yield</code> 같은 suspend 함수를 넣어주는게 맞는듯.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5d86511b-d223-4b25-97ad-a675ba8df662" class="code"><code class="language-Kotlin">val job1 = launch {
    job1StartTime = Instant.now()
    println(&quot;yieldingJob1 entry point&quot;)
    (1..5).forEach {
        println(&quot;yieldingJob1 doing its job... #$it&quot;)
        val currentTaskStartTime = Instant.now()
        while(Instant.now().minusMillis(50).isBefore(currentTaskStartTime)) {
            // blocks this thread.
        }
        println(&quot;yieldingJob1 #$it done.&quot;)
        yield()
    }
}

val job1CancellingJob = launch {
    while (Instant.now().minusMillis(100).isBefore(job1StartTime)) {
        // waiting for job1 to timeout.
        yield()
    }
    println(&quot;job1 timeout. Cancelling...&quot;)
    job1.cancel()
}</code></pre><p id="eaa8427d-ab9c-4014-a864-3bd1b8c8bfe3" class="">이런 식으로 다른 곳에서 직접 취소시키는 방법이 있는가 하면 코루틴이 스스로 내가 취소됐는지 확인하여 예외를 던지는 방식으로 종료할 수도 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="778390f9-e5cc-45d4-9b51-7faa720893ab" class="code"><code class="language-Kotlin">val cancelMeJob = launch(Dispatchers.Default) {
    println(&quot;cancelMeJob entry point&quot;)
    (1..5).forEach {
        println(&quot;cancelMeJob doing its job... #$it&quot;)
        Thread.sleep(50)
        println(&quot;cancelMeJob #$it done.&quot;)
        if (!isActive) {
            throw CancellationException(&quot;cancelMeJob is cancelled.&quot;)
        }
    }
    println(&quot;cancelMeJob terminated&quot;)
}
delay(100)
cancelMeJob.cancel()
println(&quot;cancelMeJob cancelled.&quot;)</code></pre><p id="120a3589-d516-4dc6-b91a-2e8b5472ec81" class="">위에서 언급했듯이 코루틴 안에서는 CoroutineScope의 <code>isActive</code> 라는 필드를 참조할 수 있는데 이는 해당 코루틴이 취소되었는지 여부를 나타낸다. 그래서 첫 번째 예시처럼 굳이 suspend 할 필요 없이 if 문 하나만으로 취소여부를 확인하여 취소되지 않았다면 스레드를 양보하지 않고 작업을 계속 진행할 수 있다.</p><p id="bfb3cfb1-02ce-46f5-bb22-eea92f8ea00e" class="">이 경우는 조금 특이하게 작업을 실행할 때 <code>launch</code> 함수의 파라미터로 Dispatchers.Default를 넘겼는데 이는 내부적으로 타고 들어가보면 CoroutineContext의 구현체로 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-executor-coroutine-dispatcher/">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-executor-coroutine-dispatcher/</a> 라는, java.util.concurrent.Executor를 사용하는 CoroutineDispatcher다.</p><blockquote id="400f0aa8-2454-4e85-a67d-c775e97f8519" class="">The coroutine context includes a <em>coroutine dispatcher</em> (see <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html">CoroutineDispatcher</a>)<br/> that determines what thread or threads the corresponding coroutine uses<br/> for its execution. The coroutine dispatcher can confine coroutine <br/>execution to a specific thread, dispatch it to a thread pool, or let it <br/>run unconfined.<br/></blockquote><p id="4b953cc9-384b-49b7-931f-61548c5be58f" class="">이는 <code>runBlocking</code> 으로 이 코루틴을 시작한 스레드와 같은 스레드에서 <code>cancelMeJob</code> 코루틴을 실행한다면 해당 코루틴이 양보하고 있지 않기 때문에 작업이 끝나기 전까지 해당 코루틴에 취소 시그널을 보낼 수 없기 때문이다. 그래서 별도의 스레드에서 실행시키는 디스패처로 코루틴을 실행시켜야 메인 스레드가 취소 시그널을 보내는 코드에 도달할 수 있다.</p></details></li></ul><ul id="f5a6f4cd-eb8f-49bc-98aa-72e1d45dd1a6" class="toggle"><li><details open=""><summary>코루틴의 에러 처리</summary><p id="b087db4a-a414-487e-9c3f-a5ea035a4454" class="">에러 처리 자체를 들어가기에 앞서 코루틴의 상하관계를 생각해보자. 위의 예제처럼 runBlocking으로 코루틴에 진입하고 그 안에서 launch로 코루틴을 실행시켰을 때 runBlocking의 코루틴을 최상위root 또는 부모 코루틴, 그 안에서 launch로 만든 코루틴을 자식 코루틴이라고 한다. 이때 코루틴 빌더에서 새로운 코루틴 영역, 즉 CoroutineScope로 코루틴을 시작한다면 이는 자식 코루틴이 아니라 부모 코루틴이 된다.</p><blockquote id="73440650-166b-47aa-a3d9-c0dd79820039" class="">We, of course, can manipulate contexts and jobs manually to tie the lifecycles of the activity and its coroutines, but <code>kotlinx.coroutines</code> provides an abstraction encapsulating that: <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html">CoroutineScope</a>. You should be already familiar with the coroutine scope as all coroutine builders are declared as extensions on it.</blockquote><p id="0f1e7c5a-5dbc-4d8d-9020-b0bfb05295ec" class="">코루틴에서는 모든 코루틴들의 생명주기를 관리하기 위해 코루틴을 CoroutineScope에서 관리한다. 새로운 코루틴을 생성하는 <code>launch</code> 같은 코루틴 빌더들도 <code>public fun CoroutineScope.launch</code> 처럼 코루틴 스코프의 확장 함수로 정의되어 있다. 즉 기존에 코루틴 빌더(<code>runBlocking</code> 등)로 생성한 코루틴 스코프에서 <code>launch</code> 로 코루틴을 실행시키면 같은 스코프에 속하는 <strong>자식</strong> 코루틴을 만들게 되는 것이다.</p><p id="39f812cc-5b2c-4793-856b-e307ca1891c4" class="">그러나 스코프를 새로 만들어서 코루틴을 실행시킨다면 그 코루틴은 새로운 스코프의 독자적인 <strong>부모</strong> 코루틴이 된다. 이 경우 예외 처리의 차이점은 <strong>원래 부모 코루틴은 자식 코루틴이 하나라도 실패하는 경우 모든 자식 코루틴이 다같이 실패 처리</strong>가 되지만 새로운 스코프에서 코루틴을 실행시켜서 부모 코루틴으로 취급한다면 예외가 전파되지 않는다는 것이다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f6b29ce8-802a-44a7-a0c0-559b906231e0" class="code"><code class="language-Kotlin">println(&quot;exceptionAsyncJob Started&quot;)
launch { // 300ms 뒤에 실패하는 코루틴
    println(&quot;exceptionLaunchJob Started&quot;)
    delay(300)
    throw IllegalArgumentException(&quot;cancel all jobs?&quot;)
}
val exceptionAsyncJob = async {
    val start = Instant.now()
    var counter = start
    while(Instant.now().minusMillis(500).isBefore(start)) {
        // 500ms 동안 작업하는 코루틴
        if (!isActive) {
            println(&quot;exceptionAsyncJob is cancelled.&quot;)
            throw CancellationException(&quot;exceptionAsyncJob is cancelled.&quot;)
        }
        // 약 100ms 마다 작업 진행상황을 기록한다.
        if (Instant.now().minusMillis(100).isAfter(counter)) {
            println(&quot;exceptionAsyncJob waiting...&quot;)
            counter = Instant.now()
        }
        // launch 코루틴이 실패할 틈을 주도록 yield.
        yield()
    }
    println(&quot;exceptionAsyncJob waiting done.&quot;)
}
delay(1000)
println(&quot;delayed 1000ms.&quot;)</code></pre><p id="c97f1bb1-97ba-4adf-b48f-f92b079da7b7" class="">기존 예시엔 보이지 않았지만 <code>launch</code> 로 만든 코루틴에서는 에러가 발생하면 그 에러는 자동으로 부모 코루틴으로 전파된다. <code>async</code>, <code>produce</code> 같은 빌더에서는 별도로 사용자가 에러를 받아볼 수 있게 하지만 어쨌든 <strong>자식 코루틴에서 에러가 발생한다면 그 영향으로 부모 코루틴에 에러가 전파</strong>되고 부모 코루틴은 모든 자식 코루틴의 작업을 중단시키게 된다. 그렇기 때문에 위의 코드에서 출력은 다음과 같다.</p><p id="3f06019d-2107-4571-afcf-aa2884c1f7b3" class="">[                          main][01:45:49.247] exceptionAsyncJob Started<br/>[                          main][01:45:49.258] exceptionLaunchJob Started<br/>[                          main][01:45:49.358] exceptionAsyncJob waiting...<br/>[                          main][01:45:49.458] exceptionAsyncJob waiting...<br/>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: cancel all jobs? (후략)<br/></p><p id="05d29c0d-3ca9-41f6-b4e8-e800a69e42b9" class="">그러나 자식 코루틴이 아니라면 어떨까?</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1c89f603-43de-4839-aa3f-6c99cfe48555" class="code"><code class="language-Kotlin">CoroutineScope(Default).launch { ... }</code></pre><p id="0572d647-859b-49c3-aa7a-7aa134c719a0" class=""><code>CoroutineScope()</code> 함수로 새로운 스코프에 코루틴을 만든다면 이는 아예 별개의 부모 코루틴이기 때문에 <code>runBlocking</code> 코루틴으로 에러가 전파되지 않아 <code>async</code> 코루틴은 정상적으로 작업을 종료할 수 있고 delay 이후의 메시지도 출력할 수 있다.</p><p id="3ff17625-de3c-4ff3-a7b3-98544c5962dc" class="">[                          main][01:52:06.295] exceptionAsyncJob Started<br/>[    DefaultDispatcher-worker-1][01:52:06.306] exceptionLaunchJob Started<br/>[                          main][01:52:06.408] exceptionAsyncJob waiting...<br/>[                          main][01:52:06.508] exceptionAsyncJob waiting...<br/>[                          main][01:52:06.608] exceptionAsyncJob waiting...<br/>Exception in thread &quot;DefaultDispatcher-worker-1&quot; java.lang.IllegalArgumentException: cancel all jobs<br/>(중략)<br/>[                          main][01:52:06.708] exceptionAsyncJob waiting...<br/>[                          main][01:52:06.808] exceptionAsyncJob waiting done.<br/>[                          main][01:52:07.313] delayed 1000ms.<br/></p><p id="04df498b-5582-4b3a-9ecc-ff5c7ce5e8a8" class="">이 경우 저쪽 다른 스코프에서 발생한 에러는 uncaught error, 즉 처리되지 않은 예외로 취급되며 <code>CoroutineExceptionHandler</code> 이라는 다른 처리기를 통해 처리할 수 있다. 예외가 발생했지만 어딘가에서 처리된 게 아니라 그쪽 스코프에서도 최상위 부모 코루틴, 즉 <code>launch</code> 빌더로 만든 코루틴까지 올라가고도 처리가 안 되서(다행히 메인까지 오지는 않았지만) 스택트레이스까지 띄우고 비정상 종료됐으니 처리되지 않은 에러라고 보는 것이 적절할 것이다.</p><p id="58c39c42-71d2-4bed-a7fa-6a801f7ced12" class="">그렇다면 <code>async</code> 로 만든 코루틴은 어떨까? 이 코루틴은 기본적으로 실행은 시켜도 <code>await</code> 으로 결괏값을 가져오지 않는 이상 값을 반환하지 않는다. 이는 해당 코루틴의 결괏값 뿐 아니라 <strong>코루틴 안에서 발생한 예외에도 해당</strong>된다.</p><blockquote id="a74c49b6-fc83-4f9a-a635-020431aaa7c0" class="">Awaits for completion of this value without blocking a thread and resumes when deferred computation is complete, returning the resulting value or throwing the corresponding exception if the deferred was cancelled.</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d3e46a94-8a1f-4a9d-bf45-fd5db0ab6719" class="code"><code class="language-Kotlin">println(&quot;exceptionLaunchJob Started&quot;)
CoroutineScope(Default).launch {
    // 1000ms 동안 실행되며 100ms 마다 진행상황을 기록하는 코루틴.
    val start = Instant.now()
    var counter = start
    while(Instant.now().minusMillis(1000).isBefore(start)) {
        // waiting...
        if (Instant.now().minusMillis(100).isAfter(counter)) {
            println(&quot;exceptionLaunchJob waiting...&quot;)
            counter = Instant.now()
        }
    }
    println(&quot;exceptionLaunchJob waiting done.&quot;)
    // 진행이 끝났다면 예외를 발생시킨다.
    throw IllegalArgumentException(&quot;exceptionLaunchJob is throwing an exception.&quot;)
}

println(&quot;exceptionAsyncJob Started&quot;)
val exceptionAsyncJob = CoroutineScope(Default).async {
    // 똑같이 1000ms 동안 실행되며 100ms 마다 진행상황을 기록하는 코루틴.
    val start = Instant.now()
    var counter = start
    while(Instant.now().minusMillis(1000).isBefore(start)) {
        // waiting...
        if (Instant.now().minusMillis(100).isAfter(counter)) {
            println(&quot;exceptionAsyncJob waiting...&quot;)
            counter = Instant.now()
        }
    }
    println(&quot;exceptionAsyncJob waiting done.&quot;)
    // 진행이 끝났다면 예외를 발생시킨다.
    throw IllegalArgumentException(&quot;exceptionAsyncJob is throwing an exception.&quot;)
}
delay(2000)
println(&quot;delayed 2000ms.&quot;)
println(&quot;1 + 2 : ${1 + 2}&quot;)</code></pre><p id="02fb4d58-10d8-49e1-bf60-ab50e017ff6e" class="">위와 같은 코드를 실행했을 때 출력은 다음과 같다.</p><p id="4e1fca6e-00e0-4a8d-aa5b-f4c2c5629c21" class="">[                          main][00:32:19.372] exceptionLaunchJob Started<br/>[                          main][00:32:19.385] exceptionAsyncJob Started<br/>[    DefaultDispatcher-worker-1][00:32:19.485] exceptionLaunchJob waiting...<br/>[    DefaultDispatcher-worker-2][00:32:19.485] exceptionAsyncJob waiting...<br/>(중략)<br/>[    DefaultDispatcher-worker-1][00:32:20.385] exceptionLaunchJob waiting done.<br/>[    DefaultDispatcher-worker-2][00:32:20.385] exceptionAsyncJob waiting done.<br/>Exception in thread &quot;DefaultDispatcher-worker-1&quot; java.lang.IllegalArgumentException: <br/><strong>exceptionLaunchJob</strong> is throwing an exception.<br/>(중략)<br/>[                          main][00:32:21.394] delayed 2000ms.<br/>[                          main][00:32:21.394] 1 + 2 : 3<br/></p><p id="379c8e23-6675-49a4-bbfd-a6381d4895da" class=""><code>launch</code> 로 생성한 코루틴에서 발생한 예외의 스택트레이스를 출력하고 있는 반면 <code>async</code> 로 생성한 코루틴에서 발생한 예외는 아무것도 출력되지 않는 것을 볼 수 있다. 물론 두 코루틴의 예외는 부모 코루틴에 영향을 끼치지 않았기 때문에 마지막 ‘1 + 2 : 3’ 까지 잘 실행된 것을 볼 수 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="abac60b5-e720-4b25-ae2d-533ec2540d27" class="code"><code class="language-Kotlin">println(&quot;delayed 2000ms.&quot;)
println(&quot;1 + 2 : ${1 + 2}&quot;)
exceptionAsyncJob.await()</code></pre><p id="128147d2-4875-4df8-beae-fb5154ed75ed" class="">마지막에 <code>async</code>  코루틴에 <code>await</code> 메서드로 그 결과를 가져오면 그제서야 에러를 출력하게 된다. 그럼 만약에 별도의 스코프가 아니라 <code>async</code> 코루틴을 자식 코루틴으로 생성하면 어떨까? 이 경우 <strong>코루틴 안에서 발생한 예외는 부모 코루틴으로 전파된다</strong>는 특징에 따라 별도로 <code>await</code> 할 필요 없이 예외가 전파된다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7f85d3c9-d23a-4867-afad-9462d25215de" class="code"><code class="language-Kotlin">println(&quot;exceptionAsyncJob Started&quot;)
val exceptionAsyncJob = async {
    val start = Instant.now()
    var counter = start
    while(Instant.now().minusMillis(500).isBefore(start)) {
        // waiting...
        if (Instant.now().minusMillis(100).isAfter(counter)) {
            println(&quot;exceptionAsyncJob waiting...&quot;)
            counter = Instant.now()
        }
    }
    println(&quot;exceptionAsyncJob waiting done.&quot;)
    throw IllegalArgumentException(&quot;exceptionAsyncJob is throwing an exception.&quot;)
}
delay(1000)
println(&quot;delayed 1000ms.&quot;)
println(&quot;1 + 2 : ${1 + 2}&quot;)</code></pre><p id="c5f8b9c3-f45d-4b39-852b-3ee80130da00" class="">위와 같은 코드는 다음과 같은 결과를 출력한다.</p><p id="bd49aab2-48bb-4402-8bf2-e66d97cc4c14" class="">[                          main][00:56:34.215] exceptionAsyncJob Started<br/>[                          main][00:56:34.327] exceptionAsyncJob waiting...<br/>[                          main][00:56:34.427] exceptionAsyncJob waiting...<br/>[                          main][00:56:34.527] exceptionAsyncJob waiting...<br/>[                          main][00:56:34.627] exceptionAsyncJob waiting...<br/>[                          main][00:56:34.727] exceptionAsyncJob waiting done.<br/>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: exceptionAsyncJob is throwing an exception.<br/></p><p id="bc36e495-2743-4356-9318-3f850f787359" class="">별도 스코프로 만든 <code>async</code>는 <code>await</code> 해서 에러를 가져와야 했던 것과 달리 같은 스코프의 자식 코루틴 <code>async</code> 는 그냥 에러가 전파되는 것을 알 수 있다.</p><hr id="6a98d7e2-8b51-44ee-b125-1e936d5415e4"/><p id="66f38fb3-a993-4a87-ba2c-9e4052e91c6f" class="">그러면 만약 이렇게 자식 코루틴에서 발생하는 에러가 부모 코루틴에 전파되는걸 원하지 않는다면 매번 새로운 스코프에 부모 코루틴으로 만들어야 할까? 그렇지 않다. 여기서는 코루틴의 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/</a> 이라는 인터페이스의 구현체인 <code>SupervisorJob</code> 을 활용할 수 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a539eced-cdf1-429c-b3bd-9c8a2b941afe" class="code"><code class="language-Kotlin">val exceptionAsyncJob = async(SupervisorJob()) { ... }</code></pre><p id="cb387a6e-c6a0-4d5e-8bcf-a39cb4dd1ea2" class="">위처럼 자식 코루틴을 생성할 때 SupervisorJob을 등록하면 자식 코루틴은 에러를 발생하더라도 이를 부모로 전파하지 않는다. 이 클래스에 대한 설명은 다음과 같다.</p><blockquote id="0a59fe3b-2fb7-44c0-a7e9-b0f9ef04d0ad" class="">Children of a supervisor job can fail independently of each other.<p id="0cadafcf-b3f5-4425-b7ff-fe33c5286f28" class="">A failure or cancellation of a child does not cause the supervisor job to fail and does not affect its other children, so a supervisor can implement a custom policy for handling failures of its children:</p><ul id="c2452914-db66-467c-bd05-836e30ca3f63" class="bulleted-list"><li style="list-style-type:disc">A failure of a child job that was created using launch can be handled via CoroutineExceptionHandler in the context.</li></ul><ul id="a8d2f1b8-e00a-4dc9-a0af-58062bb3cd6f" class="bulleted-list"><li style="list-style-type:disc">A failure of a child job that was created using async can be handled via Deferred.await on the resulting deferred value.</li></ul></blockquote><p id="b119812f-e1ac-45de-b04d-fe73587f2293" class="">즉 이 SupervisorJob이 관리하고 있는 자식 코루틴들은 서로 독립적으로 실패할 수 있고 실패 자체도 SupervisorJob 자체에 전파되지 않는다는 것이다. 그렇기 때문에 자식 코루틴의 실패를 좀 더 유연하게 처리할 수 있다.</p><ol type="1" id="82595edf-cf49-4ffd-b489-a967c1291032" class="numbered-list" start="1"><li> <code>launch</code> 코루틴 빌더같은 경우 코루틴 컨텍스트에 <code>CoroutineExceptionHandler</code> 라는 핸들러를 정의하여 처리할 수 있다.</li></ol><ol type="1" id="bc853715-27f1-449f-aaed-db16aa053c26" class="numbered-list" start="2"><li><code>async</code> 코루틴 빌더의 경우 <code>await</code> 메서드를 통해 값을 얻어올 때 발생가능한 예외를 try-catch 등으로 잡아서 처리할 수 있다.</li></ol><p id="740f4352-ddcd-439b-b7cd-ade415996f96" class="">이런 경우는 단방향unidirectional적인 예외 처리라 할 수 있는데 자식 코루틴에서 예외가 발생해도 부모 코루틴에는 아무런 일도 없기 때문이다. 자식 코루틴이 실패하면 부모 코루틴도 실패하고 부모 코루틴이 실패하면 모든 자식 코루틴을 취소하는 양방향bidirectional적인 예외 처리와 달리 안드로이드의 UI 컴포넌트, 자식 프로세스를 만드는 서버 프로세스 등 자식 중 하나가 실패한다고 전체가 실패할 이유는 없는 경우에 사용된다. 이때 부모 코루틴에서 실패한 자식 코루틴들을 찾아서 재시작하는 등 관리supervise해야 할 필요가 있을 때 이 SupervisorJob을 활용할 수 있다.</p><p id="96076397-5200-4e18-aba9-c37c02776d3e" class=""><a href="https://kotlinlang.org/docs/exception-handling.html#supervision-job">https://kotlinlang.org/docs/exception-handling.html#supervision-job</a> 에서는 SupervisorJob이 에러를 아래 방향, 즉 자식 코루틴에게만 전파하는 식으로 동작한다고 설명하고 있다. 부모 대신에 자식 코루틴들을 관리하며 예외 전파를 차단하는 중간 관리자, 즉 supervisor의 역할이라고 할 수 있다. 그러면 이 SupervisorJob은 어떻게 이를 차단하고 있을까?</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="31143b25-fed5-4bfd-80d6-f963ee93f308" class="code"><code class="language-Kotlin">private class SupervisorJobImpl(parent: Job?) : JobImpl(parent) {
    override fun childCancelled(cause: Throwable): Boolean = false
}</code></pre><p id="f18d0396-23c2-40f7-8843-d7d96b738a0d" class=""><code>SupervisorJob()</code> 함수는 <code>SupervisorJobImpl</code> 클래스의 객체를 생성한다. 눈에 띄는 부분은 바로 <code>childCancelled</code> 라는 메서드가 항상 false를 반환하도록 재정의되어 있다는 것이다. 이 메서드의 설명은 다음과 같다.</p><blockquote id="bb89f0e4-10dd-4e24-b7a5-8219b564f98a" class="">Child was cancelled with a cause. In this method parent decides whether it cancels itself (e.g. on a critical failure) and whether it handles the exception of the child. It is overridden in supervisor implementations to completely ignore any child cancellation. Returns true if exception is handled, false otherwise (then caller is responsible for handling an exception)</blockquote><p id="704137e8-d34c-4274-b66f-644b7a2fe84d" class="">즉 자기가 부모 코루틴이라는 관점에서 자신의 자식 코루틴이 실패했는지 그리고 그에 따라 자기 자신도 취소해야 하는지를 판단하는 메서드인데 항상 false로 재정의되어 모든 자식 코루틴의 취소(또는 실패)를 무시하도록 되어있는 것이다. 그렇기 때문에 해당 자식 코루틴은 예외를 스스로 처리해야 한다는 차이점이 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4300a6a0-06c8-4eeb-a845-56f274a61a7c" class="code"><code class="language-Kotlin">val launchJobHandler = CoroutineExceptionHandler { ctx, throwable -&gt;
    println(&quot;Caught $throwable&quot;)
}

val spvJob = SupervisorJob()
// #1. SupervisorJob에 에러 처리기를 등록해서 IllegalArgumentException을 처리한다.
launch(spvJob + launchJobHandler) {
    println(&quot;1 + 1 = 3 ?&quot;)
    throw IllegalArgumentException(&quot;1 + 1 != 3&quot;)
}
// #2. 에러가 발생하지 않는 자식 코루틴은 SupervisorJob에서 아무런 문제가 없다.
launch(spvJob) {
    println(&quot;1 + 1 = 2 ?&quot;)
    println(&quot;1 + 1 == 2&quot;)
}
// #3. 별도 스레드에서 부모 코루틴으로 생성된 자식 코루틴에 등록한 예외 처리기가 예외를 처리한다.
CoroutineScope(Default).launch(launchJobHandler) {
    println(&quot;2 + 2 = 5 ?&quot;)
    throw IllegalArgumentException(&quot;2 + 2 != 5&quot;)
}
println(&quot;launched jobs&quot;)
yield()
println(&quot;yield complete&quot;)
delay(1000)</code></pre><p id="2e282e25-9608-40a8-a290-363a8414e0d9" class="">위의 코드를 실행하면 SupervisorJob이 launchJobHandler로 보고 있는 코루틴의 “1 + 1 ≠ 3” 예외와 별도 스레드에서 새로운 스코프로 생성되어 부모 코루틴으로 동작하는 자식 코루틴의 “2 + 2 ≠ 5” 예외가 모두 CoroutineExceptionHandler에 의해 처리된다. 이를 등록하지 않아도 첫 번째 예외는 SupervisorJob이 잘 막아주고 있고 두 번째 예외는 별도 스코프에서 발생하기 때문에 메인 스레드의 코루틴은 동작에 문제가 없다. 하지만 처리되지 않은 예외가 스택 트레이스로 출력된다.</p><p id="2d7857a2-899f-4489-9613-2ade3cff063c" class=""><code>supervisorScope</code> 라는 코루틴 스코프를 사용할 수도 있는데 이는 스코프를 만들 때 SupervisorJob을 포함하는 기능을 한다.</p><hr id="1f1052be-eb25-4fa8-8fd2-ea54ff9edc1f"/><p id="d3a025c6-5d9b-4313-b8ff-5161bcbcef33" class="">이제 아까 언급했던 <code>CoroutineExceptionHandler</code> 에 대해 알아보자. 이 핸들러는 코루틴 코드 안에 에러 발생 지점에 try-catch를 하는 것과 달리 이미 에러가 발생된 후에 동작한다. 즉 여기서 뭘 한다고 해서 이미 발생한 예외를 처리할 순 없고 그렇기 때문에 로깅이나 다른 후처리에 유용한데 다음처럼 람다로 정의할 수 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6b15364d-0f55-40ba-95d9-4dee9640aebe" class="code"><code class="language-Kotlin">val launchJobHandler = CoroutineExceptionHandler { ctx, throwable -&gt;
    println(&quot;Caught $throwable&quot;)
}

CoroutineScope(Default).launch(launchJobHandler) { ... }</code></pre><p id="271b7ee2-cee9-4ec4-a673-db3c32b6c394" class="">이 핸들러를 부모 코루틴의 코루틴 빌더에 넘겨주면 코루틴 컨텍스트에 저 핸들러가 등록된다. 그리고 에러가 발생했을 때 컨텍스트에서 저 핸들러를 찾아 실행시키는 식으로 동작한다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6dfc4fff-9f93-4f79-8417-d1336fb327a7" class="code"><code class="language-Kotlin">// kotlinx.coroutines.BuildersKt__Builders_commonKt
// #1. launch로 만든 코루틴은 StandaloneCoroutine이라는 컨텍스트로 생성되는데
// 이후 이 컨텍스트를 참조할 때 context 파라미터로 전달된 컨텍스트도 포함하여 참조한다.
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job {
    val newContext = newCoroutineContext(context)
    val coroutine = if (start.isLazy)
        LazyStandaloneCoroutine(newContext, block) else
        StandaloneCoroutine(newContext, active = true)
    coroutine.start(start, coroutine, block)
    return coroutine
}

// kotlinx.coroutines.BuildersKt__Builders_commonKt
// #2. StandaloneCoroutine은 예외가 발생했을 경우 특정 함수로 점프
private open class StandaloneCoroutine(
    parentContext: CoroutineContext,
    active: Boolean
) : AbstractCoroutine&lt;Unit&gt;(parentContext, initParentJob = true, active = active) {
    override fun handleJobException(exception: Throwable): Boolean {
        handleCoroutineException(context, exception)
        return true
    }
}

// kotlinx.coroutines.CoroutineExceptionHandlerKt
// #3. 그곳에서 컨텍스트에서 CoroutineExceptionHandler를 찾아 있다면 실행시킨다.
@InternalCoroutinesApi
public fun handleCoroutineException(context: CoroutineContext, exception: Throwable) {
    // Invoke an exception handler from the context if present
    try {
        context[CoroutineExceptionHandler]?.let {
            it.handleException(context, exception)
            return
        }
    } catch (t: Throwable) {
        handleUncaughtCoroutineException(context, handlerException(exception, t))
        return
    }
    // If a handler is not present in the context or an exception was thrown, fallback to the global handler
    handleUncaughtCoroutineException(context, exception)
}</code></pre><p id="83f769f1-4a82-4d23-b4ab-20cdf5ee0869" class="">이 <code>CoroutineExceptionHandler</code> 는 언급했듯이 ‘처리되지 않은 예외’를 잡는 데 사용되며 유의할 점은 <strong>최상위 부모 코루틴</strong>의 컨텍스트에 들어가야 한다는 점이다. 왜냐면 자식 코루틴은 무조건 예외 처리를 부모 코루틴으로 위임(전파)하기 때문에 등록해봤자 어차피 호출되지 않기 때문이다.</p><blockquote id="185548d2-f42f-48d9-af41-6d2fe121e09b" class=""><code>CoroutineExceptionHandler</code> is invoked only on <strong>uncaught</strong> exceptions — exceptions that were not handled in any other way. In particular, all <em>children</em> coroutines (coroutines created in the context of another <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html">Job</a>) delegate handling of their exceptions to their parent coroutine, which also delegates to the parent, and so on until the root, so the <code>CoroutineExceptionHandler</code> installed in their context is never used. In addition to that, <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async</a> builder always catches all exceptions and represents them in the resulting <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html">Deferred</a> object, so its <code>CoroutineExceptionHandler</code> has no effect either.<br/><br/><br/><a href="https://kotlinlang.org/docs/exception-handling.html#coroutineexceptionhandler">https://kotlinlang.org/docs/exception-handling.html#coroutineexceptionhandler</a></blockquote><p id="e0652562-21e0-4abc-ac41-bd4cf60c8f58" class="">그리고 마지막 줄에서 알 수 있듯이 <code>async</code> 빌더의 경우 내부적으로 사용하는 <strong>Deferred 객체가 에러 자체도 잡아서 갖고있다가</strong> 나중에 <code>await</code> 할 때 던지기 때문에 역시 CoroutineExceptionHandler가 동작할 수 없다는 특징이 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c021a0e3-e7cf-4126-967f-a0b528a42f40" class="code"><code class="language-Kotlin">// kotlinx.coroutines.JobSupport
...
// Now handle the final exception
if (finalException != null) {
    val handled = cancelParent(finalException) || handleJobException(finalException)
    if (handled) (finalState as CompletedExceptionally).makeHandled()
}
...</code></pre><p id="8d1dab1c-a2a5-404b-9e9c-51d05e8fde23" class="">코루틴의 JobSupport에서 코루틴 상태의 최종 단계? finalizingFinishingState 라는 함수에서 타는 분기인데 아마 이쪽에서 <code>cancelParent</code> 메서드를 호출해서 부모 코루틴을 취소시키는 것을 시도하고 성공했다면, 즉 자신이 자식 코루틴이라면 단락 논리로 인해 <code>handleJobException</code> 을 실행하지 않는 식으로 분기가 갈리기 때문에 자식 코루틴에 예외 처리기를 등록해도 동작하지 않는 것 같다. 반대로 부모 코루틴으로 코루틴을 만든 후에 돌려보면 <code>cancelParent</code> 가 false를 반환하고 CoroutineExceptionHandler가 컨텍스트에 등록된 경우 <code>handleJobException</code> 이 안에서 핸들러를 실행하고 true를 반환한다.</p><hr id="4faee206-ec21-4fdc-bd7a-27cfd940b194"/><p id="c259e7f0-f44b-44ba-a9ae-07a56522d738" class="">이전에 코루틴을 <code>cancel</code> 메서드로 취소시킬 때 CancellationException을 던진다고 했는데 사실 코루틴은 내부적으로 이 예외를 잡으면 모든 예외 처리기에서 무시하고 해당 코루틴을 예외 발생으로 인한 실패가 아닌 일반 취소로 처리한다. 그래서 이 경우는 따로 부모 코루틴을 취소시키지 않고 자식 코루틴만 종료한다.</p><p id="c62d9bcf-33a6-4221-af10-1ab9f49627f9" class="">그러나 이 예외가 아니라 다른 예외를 만난다면 어떨까? 이는 코루틴을 의도적으로 취소시킨 게 아니라 예상치 않은 예외가 발생한 것이기 때문에 부모 코루틴까지 취소시킨다. 이 동작은 코루틴 자체에서 structured concurrency라는 개념을 달성하기 위해 강제된다.</p><p id="b68219b7-fb0b-44ed-83ba-4627b64a8fd3" class="">위에서 자식 코루틴이 CoroutineExceptionHandler를 재정의해도 실제 예외 상황에서 불리지 않던 걸 생각해보면 알 수 있는데 만약 CancellationException이 아닌 예외가 발생해도 핸들러에서 이 에러를 다시 던지지 않는다면 부모 코루틴은 자식 코루틴에 에러가 발생해도 알지 못하고 계속 동작하게 된다. 그럼 왜 자식 코루틴에서 처리되지 않은 에러가 발생했을 때 부모 코루틴도 실패해야 할까? 이건 언급했던 structured concurrency와 관련이 있는데 좀 더 나중에 알아본다.</p><p id="0c3ab344-799d-44b2-a1f0-e2104ef7b3ae" class="">
</p></details></li></ul><ul id="c23fa526-5ffa-4a00-9d88-bf01f285af47" class="toggle"><li><details open=""><summary>Structured Concurrency</summary><p id="a2f2ea05-da3a-4317-b064-d43ccfdaedbd" class="">코루틴은 <code>Job</code> 이라는 인터페이스로 표현는데 이 Job은 개념적으로는 작업완료 시 종료되고 생명주기를 갖는 취소가능한 것이라고 표현한다. 코틀린 공식 문서의 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/</a> 문서에서 몇 가지 특징을 빌려오면 다음과 같다.</p><ul id="2208de18-b4fb-441e-838f-8536b876b336" class="bulleted-list"><li style="list-style-type:disc">부모-자식간의 구조로 배치되어 부모가 취소되면 재귀적으로 자식의 자식까지 모두 취소한다.</li></ul><ul id="8b0bab0c-72ca-4ba9-ad7e-e2e4164f3b11" class="bulleted-list"><li style="list-style-type:disc">자식에서 예외가 발생했을 때 CancellationException이 아닌 경우 해당 자식과 부모까지 취소한다.<ul id="ddaf4b34-141e-4897-b305-eed0720a1c30" class="bulleted-list"><li style="list-style-type:circle">이는 첫 번째 특징와 작용하여 결과적으로 같은 구조내의 모든 코루틴이 취소되도록 한다.</li></ul><ul id="f4d54b72-078c-4f0a-a40c-2a10311bd7de" class="bulleted-list"><li style="list-style-type:circle">이 행동은 SupervisorJob을 이용하여 재정의할 수 있다.</li></ul></li></ul><p id="3c270bc7-804f-42b6-b467-414ded68aff1" class="">코루틴을 생성할 때 <code>launch</code> 같은 코루틴 빌더로 생성하는 경우 <code>CoroutineJob</code> 구현체가 되고 <code>Job()</code> 같은 팩토리 함수를 이용하는 경우 <code>CompletableJob</code> 구현체가 된다고 한다. 차이점은 전자는 빌더 내부의 람다로 지정된 코드 블록을 실행하고 알아서 종료되지만 후자는 직접 <code>complete</code> 메서드를 호출해서 종료시켜줘야 한다는 것이 있다.</p><p id="d21bfab6-df8f-4d13-8a0a-e3ae045a4331" class="">개념적으로 이 Job 인터페이스는 결과를 반환하지 않는 것을 가정하고 있다. 이들은 React에서 useEffect의 effect처럼 오직 사이드 이펙트를 위해서 실행되며 만약 작업의 실행 결과를 얻고 싶다면 하위 인터페이스인 <code>Deferred</code> 를 사용할 수 있다. 이전에 결과를 얻기 위해 코루틴을 만들던 <code>async</code> 코루틴 빌더가 바로 이 인터페이스의 구현체를 생성하는 것이다.</p><p id="7fb8064e-64a7-43ca-92f3-98d4e7f7fabf" class="">이렇게 만들어진 코루틴, Job은 그 실행 단계에 따라 여러가지 내부 상태를 가진다. 실행 단계는 initial, transient, final 로 구분되는데 각 단계별로 New, Active와 Completing, Cancelling 그리고 Cancelled, Completed 상태가 있다. 이전에 코루틴의 취소를 확인할 때 사용했던 <code>isActive</code> 메서드같은 <code>isActive</code>, <code>isCompleted</code>, <code>isCancelled</code> 상태확인 메서드를 이용하여 해당 Job이 무슨 상태인지 알 수 있다.</p><ol type="1" id="4def7fc3-98fc-4276-8410-772097818bd6" class="numbered-list" start="1"><li>New: 코루틴을 생성했을 때 기본적으로는 바로 작업을 시작하지만 LAZY 옵션을 주면 실행되지 않고 대기하던 것을 떠올릴 수 있는데 이 상태라 바로 New 상태라고 할 수 있다. 이 경우 모든 상태확인 메서드에서 false를 반환한다.</li></ol><ol type="1" id="1b728e9a-fc58-4ed8-8636-6d57f278957e" class="numbered-list" start="2"><li>Active: 별도로 LAZY 옵션을 주지 않고 코루틴을 생성했을 때 적용되는 상태로 생성되자마자 실행중인 상태다. 위의 <code>isActive</code> 상태확인 메서드에서만 true를 반환한다. 만약 LAZY 옵션으로 생성되어 New 상태에 머물고 있는 Deferred 코루틴이라면 <code>start</code>, <code>join</code>, <code>await</code> 메서드를 이용하여 실행시킬 때 이 Active 상태로 진입한다.</li></ol><ol type="1" id="e0f85f39-9faa-42f8-9695-ec1b927f4729" class="numbered-list" start="3"><li>Cancelling: Active 상태로 진행중인 Job이 처리되지 않은 예외를 던지면서 실패한다면 또는 외부에서 명시적으로 <code>cancel</code> 등의 메서드를 호출하여 취소시킨다면 코루틴은 Cancelling 상태로 진입한다. 그러나 바로 종료되는 것은 아니고 cleanup 작업이나 다른 작업들의 종료를 기다릴 수 있다.</li></ol><ol type="1" id="36358c20-1656-4d34-8405-04ad3104810e" class="numbered-list" start="4"><li>Cancelled: 위의 Cancelling 상태에서 해당 코루틴의 취소가 완료되고 더 이상 코드를 실행하지 않는 경우, 즉 완전히 취소된 경우 Cancelled 상태가 될 수 있다.</li></ol><ol type="1" id="9f86e54a-dd27-4954-bc4a-88083e8b9b5f" class="numbered-list" start="5"><li>Completing: Cancelling과는 반대로 코루틴 작업이 완료되거나 명시적으로 <code>complete</code> 등의 메서드를 호출하여 작업을 완료시키는 경우 코루틴은 Completing 상태로 진입한다. Cancelling과 비슷하지만 작업의 ‘완료’는 별도로 cleanup이 없을 것이고(그것까지 작업의 일부라서?) 대신 자식 코루틴들의 완료를 기다리는 동안 이 상태로 유지된다. 특이한 것은 이 상태는 <strong>코루틴 내부에서만 관리</strong>되며 외부에서는 Completing 대신 Active 상태로 취급된다.</li></ol><ol type="1" id="41bca4fb-8bb6-4f92-a2c9-e2bf68033c8d" class="numbered-list" start="6"><li>Completed: 위의 Completing 상태에서 코루틴의 작업이 완전히 종료되고 자식 코루틴까지 완료된 경우 Completed 상태가 될 수 있다.</li></ol><p id="7d0106fe-808c-43ec-8104-9a487b423844" class="">특이한 것은 코루틴은 작업을 실행하다가 코드에서 예외가 발생하여 작업이 취소되는 경우 <strong>exceptionally completed</strong>라고 한다. <code>CompletableJob.completeExceptionally()</code> 라는 메서드에서도 볼 수 있듯이 예외가 발생하여 완료되었다고 표현하는 이 상태는 최종적으로 어쨌든 4번 Cancelled 상태로 진입하게 되는데 이 경우 예외가 발생하지 않았지만 그냥 취소된 코루틴도 결국 4번 Cancelled가 되기 때문에 이를 구분할 수 없다.</p><p id="c98e4371-b868-458c-a941-c2ff34aedc2f" class="">예외가 발생해서 취소된 것을 실패(FAIL), 그냥 외부에서 취소시킨 것을 취소(CANCEL)라 할 때 실패와 취소를 어떻게 구분할 수 있을까? 코루틴에서는 <strong>어떤 예외가 이 코루틴을 취소시켰는가</strong> 즉 cancellation cause를 확인하여 이를 구현한다. 위에서도 몇번 언급했던 <code>CancellationException</code> 이라는 예외는 코루틴에서 발생했을 때 유일하게 실패가 아니라 취소로 판단하는 예외다. 오직 이 예외가 발생했을 때 코루틴은 실패가 아닌 취소로 판단하고 자기 자신과 자식 코루틴만 취소시키고 부모 코루틴에세 실패를 전파하지 않는다. 그러나 다른 예외가 발생하는 경우 Structured Concurrency라는 것을 위해 부모 코루틴에 실패를 전파하게 된다.</p><p id="6bf2747a-ac98-4dd4-9b70-dd497a5f4782" class="">서론이 길었지만 중요한 것은 부모 코루틴은 structured concurrency, 즉 구조적 동시성을 위해 자식 코루틴의 완료를 기다리거나 취소시킨다는 것이고 이를 통해 우리는 하나의 코루틴에서 생성한 수많은 코루틴들이 <strong>유실되거나 누수되지 않고</strong> 에러를 캐치할 수 있다는 것이다.</p><blockquote id="20848446-3116-45c4-879b-ec88ee38ac29" class="">Structured concurrency means concurrent tasks have their owners, tasks consists of smaller sub-tasks that are explicit to the framework. <a href="https://stackoverflow.com/a/74985322">https://stackoverflow.com/a/74985322</a></blockquote></details></li></ul><ul id="47ad9e32-22c7-46b7-8ba3-369bf60dda3b" class="toggle"><li><details open=""><summary>CoroutineScope, CoroutineContext</summary><p id="a1fff8a5-6849-4121-a1d8-63ba0d07b293" class="">지금까지 <code>runBlocking</code> 로 프로그램 코드와 코루틴 코드를 이어주었는데 사실 이 함수에는 새로운 CoroutineScope를 생성한다는 점이 숨어있다. 만약 직접 CoroutineScope를 생성한다면 이를 사용하지 않아도 작업을 실행시킬 수 있으며 이전에 다른 스레드에서 코루틴을 실행시키기 위해 CoroutineScope를 직접 생성했던 게 그 예시다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a9e2effd-fcd1-40a3-9fb9-f8f58fb4cc6e" class="code"><code class="language-Kotlin">fun main() {
    CoroutineScope(Dispatchers.Default).launch { ... }
    
    // wait until coroutine is completed or join() that job.
    Thread.sleep(...)
}</code></pre><p id="12ca9423-2185-431a-a590-33780b48bd9f" class="">사실 CoroutineScope 자체는 그냥 CoroutineContext를 필드로 가지는 단순한 인터페이스에 불과하다. 개념적으로는 코루틴을 시작할 수 있는 영역이지만 코드상으로는 그렇고 컨텍스트는 코루틴과 관련된 구성요소들(코루틴 코드 그 자체, 예외 처리기, 코루틴 이름 등)을 보관하고 있다. 이 스코프에서 부모 코루틴이 자식 코루틴을 생성할 때 부모의 컨텍스트를 자식의 컨텍스트에 복사하고 자식 코루틴은 별도로 컨텍스트 데이터를 주입하여 자식만의 컨텍스트를 가지면서 후 부모-자식 간 참조를 만들어 structured concurrency를 구현할 수 있다. 그렇기 때문에 이 코루틴 스코프 자체를 취소시키면 스코프 내의 모든 코루틴을 취소시키면서 일관성을 유지할 수 있다.</p><p id="fdd525cd-3a69-48bd-baed-155a854f2c10" class="">CoroutineContext 자체는 Map, Set을 합쳐놓은 자료구조라 할 수 있다. 이 자료구조 안에는 Element라는 구성요소들이 들어가는데 CoroutineName처럼 코루틴의 이름을 지정하는 구현체도 있고 이전에 사용했던 SupervisorJob도 사실 이 <code>CoroutineContext.Element</code> 의 구현체였다. 이런 엘리먼트들을 단독으로 코루틴 스코프의 컨텍스트로 넘기거나 아래처럼 plus 연산자를 이용하여 합쳐서 등록할 수 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4f6079be-d6a3-4dde-ac55-a22371c18d06" class="code"><code class="language-Kotlin">// Default 디스패처와 CustomScope 이름 엘리먼트를 합한 컨텍스트를 생성한다.
val customContext = Dispatchers.Default + CoroutineName(&quot;CustomScope&quot;)
val errorCausingJob = CoroutineScope(customContext).launch {
    // 실제로 컨텍스트 안에 들어간 이름 엘리먼트를 꺼내서 참조한다.
    val coroutineName = coroutineContext[CoroutineName]?.name
    println(&quot;I&#x27;m $coroutineName&quot;)
    println(&quot;2 + 2 = 5 ?&quot;)
    throw IllegalArgumentException(&quot;2 + 2 != 5&quot;)
}

// Dispatchers.Default로 인해 다른 스레드에서 실행되므로 명시적으로 기다린다.
errorCausingJob.join()</code></pre><p id="0b25322a-88f8-40c5-85ff-3affabe03472" class="">CoroutineScope 인터페이스가 <code>coroutineContext</code> 라는 필드를 정의하고 있기 때문에 코루틴 빌더 내부에서 별도 의존성 없이 바로 참조할 수 있는 것을 볼 수 있다.</p></details></li></ul><ul id="b6085b60-65b7-4c4e-b48a-1b07fed00b55" class="toggle"><li><details open=""><summary>CoroutineDispatcher</summary><ol type="1" id="e149cefa-07c8-4198-838d-fa6572033d45" class="numbered-list" start="1"><li>Default<ol type="a" id="cd779af4-e7bf-47fa-aff6-ca28e97e012f" class="numbered-list" start="1"><li>기본값으로 사용되는 디스패처.</li></ol><ol type="a" id="58aeb084-e8a2-4084-8ee2-daccd51be583" class="numbered-list" start="2"><li>CPU 사용량이 높은 일반적인 작업에 유효.</li></ol></li></ol><ol type="1" id="c310cc3e-aa9f-4f2f-b652-cfd9768c77bd" class="numbered-list" start="2"><li>IO<ol type="a" id="9ef0dacc-27b9-4196-890d-cb81796e371d" class="numbered-list" start="1"><li>말 그대로 I/O 작업에 최적화된 디스패처.</li></ol><ol type="a" id="37062601-72b3-4545-9240-edc952132644" class="numbered-list" start="2"><li>네트워크 IO, 디스크 IO 등 CPU 자원과는 관계없이 하드웨어 성능에 따라 기다려야 하는 경우 유효.</li></ol></li></ol><ol type="1" id="d32f3bc0-ec3c-4791-9c20-1cbd0aa595f7" class="numbered-list" start="3"><li>Main<ol type="a" id="4ea63ae8-4a12-4b82-a19e-316fa5b55a86" class="numbered-list" start="1"><li>안드로이드 등에서 사용하는 UI 컴포넌트에 사용되는 디스패처.</li></ol><ol type="a" id="a0873f35-a34a-494b-bce4-ea155daf3702" class="numbered-list" start="2"><li>별도의 의존성이 없으면 제대로 동작하지 않고 서버 애플리케이션에서 활용할 일은 없을듯.</li></ol></li></ol><ol type="1" id="31b3da47-ca60-4a62-8130-2fb3aff31639" class="numbered-list" start="4"><li>ExecutorService<ol type="a" id="faa12af1-c61e-4b76-a05d-94a845314684" class="numbered-list" start="1"><li>Java의 스레드 풀 같은 ExecutorService 인터페이스의 구현체를 디스패처로 활용할 수 있음.</li></ol><ol type="a" id="237983c7-563c-425c-9d11-b906bd64b6c3" class="numbered-list" start="2"><li><code>asCoroutineDispatcher()</code> 같은 확장 함수로 지원하고 있다.</li></ol></li></ol></details></li></ul><ul id="e03baf17-039b-43eb-bfbe-390688afdcd3" class="toggle"><li><details open=""><summary>Suspending Function</summary><p id="9e6779dd-5518-482b-ae01-b4b098eea41b" class=""><code>suspend</code> 가 붙은 함수의 특징은 Javascript에서 async 함수에 대해서만 await 할 수 있는 것처럼 다른 <code>suspend</code> 함수를 호출할 수 있다는 것이다. <code>launch</code> 같은 코루틴 빌더의 마지막 파라미터인 람다 함수도 그 표현식을 정의할 때 suspend 키워드가 붙어있기 때문에 우리가 작성하는 코루틴 코드에서 별도의 작업 없이도 다른 suspend 함수를 호출할 수 있는 것이다.</p><p id="9df34202-0df3-4077-b026-7746279cb328" class="">물론 이것보다는 <code>suspend</code> 함수는 중단이 되었다가 재개될 수 있는 지점을 표시한다는 것이 가장 큰 특징이다. 해당 코루틴이 중단, 즉 yield하거나 delay해서 다른 코루틴에게 작업을 양보할 수 있고 반대로 양보하고 대기중일 때 스레드를 받아서 작업을 다시 시작할 수 있는 지점을 나타낸다는 것이다.</p><p id="06e325cc-545c-43f7-b9f7-24637634aa32" class="">이 ‘중단이 되었다가 재개될 수 있는’ 지점은 꼭 delay, yield 같은 함수를 호출한다는 것이 아니고 함수 내부적으로 비동기 작업이 일어난다는 지점을 표시하는 부분이기도 하다. 예를 들어 코루틴을 사용하다가 Java의 CompletableFuture 등 다른 비동기 라이브러리를 사용하여 async한 작업을 구성하고 싶다고 할 때 코루틴의 suspend하는 <code>await</code> 메서드가 확장 함수로 지원되는 경우 다음처럼 구성할 수 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="537d0578-8374-4bf0-85d9-190ed49f0a15" class="code"><code class="language-Kotlin">suspend fun callApi(): Boolean {
    return CoroutineScope(Default).async {
        println(&quot;callApi coroutine entry point&quot;)
        Thread.sleep(1000)
        println(&quot;callApi coroutine terminated&quot;)
        true
    }.await()
}

suspend fun readDisk(): Boolean {
    return CompletableFuture.supplyAsync {
        println(&quot;readDisk coroutine entry point&quot;)
        Thread.sleep(1000)
        println(&quot;readDisk coroutine terminated&quot;)
        false
    }.await()
}

...
println(&quot;pre:callApi&quot;)
callApi()
println(&quot;post:callApi&quot;)

println(&quot;pre:readDisk&quot;)
readDisk()
println(&quot;post:readDisk&quot;)
...</code></pre><p id="111e088b-94c8-4247-b81a-1a59ea265aba" class="">이건 좀 용도가 애매한 것 같은데 추가 조사가 필요…는 뒤에서 나오는 continuation과 연관이 깊다. 암튼 이런식으로 활용 가능한 suspend 함수는 여러가지가 있다.</p><ol type="1" id="dbc6ef68-1489-412a-b630-353cf44467cf" class="numbered-list" start="1"><li>coroutineScope<ol type="a" id="d9ed4627-7250-4819-8abf-e935e6150ff2" class="numbered-list" start="1"><li>위에서 언급한 CoroutineScope 개념과 비슷하게 새로운 코루틴 스코프를 생성한다.</li></ol><ol type="a" id="86323806-19f3-4f16-9d05-e0f473755d86" class="numbered-list" start="2"><li>해당 코루틴이 종료되기 전까지 코드를 block한다. 즉 내부의 runBlocking 처럼 동작한다.</li></ol><ol type="a" id="f7a81a7b-a97f-46fc-8e8c-de8f4305a16d" class="numbered-list" start="3"><li>특정 코루틴 작업들을 묶어서 스코프 단위로 관리하고 싶을 때 사용.</li></ol></li></ol><ol type="1" id="2eeacc70-7b53-4077-a49e-00728af76c04" class="numbered-list" start="2"><li>withContext<ol type="a" id="2b2bf7c8-c93d-45c2-b472-e8d444e92e8c" class="numbered-list" start="1"><li>coroutineScope와 유사하지만 파라미터로 컨텍스트 엘리먼트를 받을 수 있음.</li></ol><ol type="a" id="4864a996-b8f7-4fb2-87df-fd15c135fd8d" class="numbered-list" start="2"><li>CoroutineContext에 원하는 Element를 넣으면서 CoroutineScope를 생성할 수 있는 느낌.</li></ol></li></ol><ol type="1" id="c9728fe4-e1ed-4d76-8e91-b05aece191cd" class="numbered-list" start="3"><li>withTimeout / withTimeoutOrNull<ol type="a" id="2bce483c-eded-4ab9-a82d-55140b7d6643" class="numbered-list" start="1"><li>주어진 시간 안에 코루틴이 완료되어야 하는 스코프.</li></ol><ol type="a" id="b337908a-c29c-4326-a6fb-2aba1f07f4d7" class="numbered-list" start="2"><li>전자는 예외를 던지고 후자는 null을 반환한다.</li></ol></li></ol></details></li></ul><ul id="31913e33-53b5-4c27-8c7a-6666617754fc" class="toggle"><li><details open=""><summary>Continuation</summary><p id="c4e87db8-793c-441b-9eeb-135243c14134" class="">이 부분은 나도 감으로 이해했기 때문에 정확히 정의를 내리기 어려운 데 일단 Continuation이란 것 자체는 CPS, <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">Continuation Passing Style</a>에서 유래한 개념이다. 함수를 호출하고 결과를 받는 통상의 절차적 프로그래밍이 아니라 함수형 프로그래밍에서 값을 반환하지 않고 대신 Continuation 이라는 객체를 함수 호출 시 파라미터로 전달하면서 코드의 진행 흐름을 제어하고 결과를 전달하는 방식이라 한다. <a href="https://stackoverflow.com/a/14022348/10242688">https://stackoverflow.com/a/14022348/10242688</a></p><p id="11d6ac90-685e-8071-a9b9-c0ed97e12e6f" class="">흐름을 제어하는데는 구현 나름이겠지만 코루틴에서는 라벨label이라는 정수형 필드로 제어하고 있으며 이 라벨 값에 따라 switch-case 분기를 태우는 방식으로 현재 <strong>상태</strong>에 따라 진입 가능한 <strong>상태</strong>가 결정된다. 이걸 보고 문득 상태 머신(State Machine)이라는 게 생각났다. 객체의 현재 상태를 기반으로 진입할 수 있는 상태를 한정짓는 패러다임이라고 이해하고 있는데 코루틴이 Continuation의 라벨, 즉 현재 상태를 기반으로 case 분기, 즉 다음 상태로 변화하는 모습이 마치 단방향의 상태 그래프를 따라가는 것 같다는 생각이 든다.</p><p id="11d6ac90-685e-806a-ba97-c9a2eb98413e" class="">앞서 suspending function 챕터에서 suspend 함수는 코루틴이 작업을 중단하거나 재개할 수 있는 지점이라 하였다. 이때 이 함수를 호출하는 지점을 기반으로 switch-case의 분기가 나뉘는데 이는 Javascript에서 async, await을 사용할 때 암묵적으로 Promise로 코드가 묶이는 것처럼 실제로 컴파일할 때 코드가 달라진다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="11d6ac90-685e-80ce-86d5-d286d36a0e3a" class="code"><code class="language-Kotlin">fun main() {
    runBlocking {
        suspendCaller()
    }
} 

suspend fun suspendCaller() {
    var printlnCalled = 0
    println(&quot;pre:callApi&quot;)
    printlnCalled++
    callApi()
    println(&quot;post:callApi&quot;)
    printlnCalled++

    println(&quot;pre:readDisk&quot;)
    printlnCalled++
    readDisk()
    println(&quot;post:readDisk&quot;)
    printlnCalled++

    println(&quot;println called $printlnCalled times&quot;)
}</code></pre><p id="11d6ac90-685e-80bc-b82a-efb542b58cda" class="">위의 코드에서는 함수를 호출하기 전후로 <code>println</code> 함수 호출, <code>printlnCalled</code> 증가 등의 작업을 수행하고 있으며 <code>callApi</code>, <code>readDisk</code> 함수는 둘 다 suspend 함수로 정의되어 있다. 위 부분을 Java로 디컴파일 해보면 <code>suspendCaller</code> 함수가 아래처럼 바뀌는 것을 볼 수 있다.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="11d6ac90-685e-80a9-b0a9-f209e4fae395" class="code"><code class="language-Kotlin">@Nullable
public static final Object suspendCaller(@NotNull Continuation var0) {
    // 타입이 보이지 않지만 아래 코드에서 ContinuationImpl로 초기화하는 것으로 보아
    // 실제 Continuation 객체를 담는 변수일 것.
    Object $continuation;
    label27: {
       if (var0 instanceof &lt;undefinedtype&gt;) {
          // 파라미터로 Continuation 객체를 받았을 경우 필드에 대입한다.
          // 다음 상태를 진행하면 자기 자신을 호출하면서 Continuation 객체를 넘기는 것.
          $continuation = (&lt;undefinedtype&gt;)var0;
          // ...
       }    
       $continuation = new ContinuationImpl(var0) {
          Object result;
          int label;
          // 이 이름없는 필드는 Continuation 내부에서 유지되어야 하는 데이터를 담는다.
          // suspend를 구분으로 나뉘는 switch-case 코드 블록, 즉 상태 간 유지되어야
          // 하는 데이터가 있다면 이 객체에 담아서 전달해야 하기 때문에 필요하다.
          int I$0;
          @Nullable
          public final Object invokeSuspend(@NotNull Object $result) {
             this.result = $result;
             this.label |= Integer.MIN_VALUE;
             // suspendCaller 함수 호출을 통해 첫 진입.
             // 이때 자기자신 즉 Continuation 객체를 넘겨서 본격적인 CPS를 시작.
             return MainKt.suspendCaller(this);
          }
       };
       // ...
    }
    
    // 필요한 필드를 switch-case 밖에서 초기화하여 모든 상태에서 접근할 수 있도록 한다.
    // &quot;필요&quot;하다는 기준은 상태 간 공유가 필요한 데이터로 여기서는 callApi(), readDisk()
    // 전후로 참조하고 있는 printlnCalled 카운터 변수, println 파라미터로 사용할
    // 문자열 변수가 해당한다. 만약 필드가 늘어나면 이곳도 늘어나게 된다.
		int printlnCalled;
		String var2;
		label22: {
		   Object $result = ((&lt;undefinedtype&gt;)$continuation).result;
		   // 이는 Kotlin 소스 코드의 Intrinsics.COROUTINE_SUSPENDED 필드를 참조한다.
		   // 특별한 건 아니고 설명에 따르면 &quot;the execution was suspended and
		   // will not return any result immediately&quot;, 즉 suspend 함수에 의해
		   // 잘 중단(suspend)되었는지 판단하기 위해 사용한다.
		   Object var5 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
		   switch (((&lt;undefinedtype&gt;)$continuation).label) {
		      case 0:
		         ResultKt.throwOnFailure($result);
		         // 위의 Kotlin 코드에서 printlnCalled 변수를 0으로 초기화하고
		         // println 함수로 &quot;pre:callApi&quot;를 호출하는 코드가 아래처럼 컴파일되었다.
		         int printlnCalled = 0;
		         var2 = &quot;pre:callApi&quot;;
		         System.out.println(var2);
		         printlnCalled = printlnCalled + 1;
		         // 이후 suspend 함수인 callApi를 호출해야 하기 때문에 Continuation 객체에
		         // 현재 상태의 필드값을 설정하고 label을 0에서 1로 설정하여 다음 상태로 진입한다.
		         ((&lt;undefinedtype&gt;)$continuation).I$0 = printlnCalled;
		         ((&lt;undefinedtype&gt;)$continuation).label = 1;
		         // callApi를 호출할 때 현재 Continuation 객체를 넘기는 것에 유의하라.
		         if (callApi((Continuation)$continuation) == var5) {
		            // suspend 함수를 호출하고 COROUTINE_SUSPENDED 상태라면 종료한다.
		            return var5;
		         }
		         break;
		      case 1:
		         // label이 0에서 callApi 호출 이후의 다음 상태 즉 1로 넘어왔다면
		         // 해당 코드 블록의 println(), printlnCalled++ 등을 실행하기 위해 
		         // 필요한 필드를 Continuation 객체에서 꺼내온다.
		         printlnCalled = ((&lt;undefinedtype&gt;)$continuation).I$0;
		         ResultKt.throwOnFailure($result);
		         break;
		      case 2:
		         // 지금은 로직이 단순하기 때문에 이곳도 거의 동일하지만 제일 마지막 상태인 경우
		         // 현재 블록인 label22 자체를 탈출해서 저 아래 하단의 &quot;post:readDisk&quot;가
		         // 있는 곳으로 진행하며 코루틴을 마무리한다.
		         printlnCalled = ((&lt;undefinedtype&gt;)$continuation).I$0;
		         ResultKt.throwOnFailure($result);
		         break label22;
		      default:
		         throw new IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;);
		   }
		   // 사람의 눈으로 보기에는 이상하지만 case 1 쪽에서 이어지는 로직으로 callApi와
		   // readDisk 사이의 코드를 실행한다. 이때 다음 suspend 함수인 readDisk를 실행하기
		   // 위해 label을 2로 증가시키는 것을 볼 수 있다.
		   var2 = &quot;post:callApi&quot;;
		   System.out.println(var2);
		   ++printlnCalled;
		   var2 = &quot;pre:readDisk&quot;;
		   System.out.println(var2);
		   ++printlnCalled;
		   ((&lt;undefinedtype&gt;)$continuation).I$0 = printlnCalled;
		   ((&lt;undefinedtype&gt;)$continuation).label = 2;
		   if (readDisk((Continuation)$continuation) == var5) {
		      return var5;
		   }
		}
		var2 = &quot;post:readDisk&quot;;
		System.out.println(var2);
		++printlnCalled;
		var2 = &quot;println called &quot; + printlnCalled + &quot; times&quot;;
		System.out.println(var2);
		return Unit.INSTANCE;</code></pre><p id="11d6ac90-685e-80e8-a540-c7104fb45c16" class="">실제로 작성한 코드와 디컴파일된 코드가 꽤나 다른 것을 볼 수 있다.모습을 보이는 것을 알 수 있다. 여기서 명시적으로 나타나지 않는 것은 Continuation 객체에서 정의된 <code>invokeSuspend</code> 등의 메서드나 위에선 생략했지만 코루틴 빌더 내의 <code>create</code> 함수 등을 누가 호출해서 진행하느냐일 것이다. 하지만 이것은 이 짧은 시간 내에 다루기엔 어려운 주제같고 대신 아래의 컨퍼런스 영상과 블로그 글을 참고하는게 좋을 것 같다.</p><p id="1216ac90-685e-80f2-a9c1-c34e6d9ff1e9" class=""><a href="https://www.youtube.com/watch?v=YrrUCSi72E8">https://www.youtube.com/watch?v=YrrUCSi72E8</a></p><p id="1216ac90-685e-80ca-86be-c20fa82d81ce" class=""><a href="https://medium.com/@jms8732/coroutine-suspend-키워드-de-e8e8c12c39d">https://medium.com/@jms8732/coroutine-suspend-키워드-de-e8e8c12c39d</a></p><p id="1216ac90-685e-8033-9c70-c16da81dc79d" class="">어쨌든 핵심은 blocking하게 작성했던 코루틴 코드가 알아서 CPS같은 기법을 적용하면서 non-blocking하게 동작할 수 있다는 것이다.</p></details></li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>