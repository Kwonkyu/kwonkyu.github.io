https://preview.mailerlite.io/emails/webview/234457/85226042257573030

> Managing Multiple Bounded Contexts with Hexagonal Architecture

bounded context: 서로다른 도메인 간에 경계(boundary)가 있어야 한다는 것을 의미
도메인에 경계가 없다면 의존성에도 경계(제한)가 없고 서로 타이트하게 결합될 것.
이렇게 결합된 도메인들은 서로 영향을 끼치기 때문에 독립적으로 발전할 수가 없게 됨. 이럴거면 애초에 도메인을 분리하지 않는 게 나았지.

코드를 분리해서 독립적으로 발전할 수 있다는 것은 큰 의미가 있음. SRP 측면에서 보면 하나의 바운디드 컨텍스트에 관련된 클래스만 수정할 때 다른 바운디드 컨텍스트에 속한 클래스에는 영향을 끼치지 않는다는 것.

이런 바운디드 컨텍스트를 육각형 아키텍처에서 어떻게 다루는 지에 대하여...
----
분리된 바운디드 컨텍스트와 육각형 아키텍처를 조합하면 제일 먼저 떠오르는 것은 바운디드 컨텍스트별로 고유한 육각형, 즉 포트와 어댑터 구조를 가지는 것이다. 각 바운디드 컨텍스트끼리 아무런 연관이 없겠다면 좋겠지만 만약 한 컨텍스트에서 다른 컨텍스트 내부에 있는 기능을 호출해야 한다면 어떨까? 호출하는 쪽에서는 아웃바운드, 호출되는 쪽에서는 인바운드 포트를 만들고 둘 사이의 호출을 맵핑할 별도의 어댑터를 만들 수 있다.

이렇게 구성하는 경우 두 컨텍스트는 분리되어 있으면서 서로 간 의존성은 포트, 어댑터로 명확히 규정되기 때문에 의도치 않은 의존성이 흘러들어갈 가능성이 낮다. 하지만 이렇게 두 컨텍스트끼리 이어주는 경우 컨텍스트가 늘어나고 그들 사이의 호출이 늘어날수록 이를 담당하는 포트와 어댑터가 기하급수적으로 많아진다. 어댑터에서 한 도메인을 다른 도메인으로 변환하는 작업은 금방 귀찮아질 것이다. 그리고 이런 경우 대부분 들이는 노력보다 얻는 효과가 더 적기 때문에 지름길을 택하게 되고 육각형 아키텍처처럼 보이지만 그의 효용은 없는 아키텍처가 되어버린다.

알리스테어 코번도 육각형 아키텍처는 하나의 바운디드 컨텍스트를 포트와 어댑터로 감싸서 캡슐화하려고 하지는 않았다. 대신 애플리케이션 관점에서의 캡슐화를 적용하려 한 것이고 이 애플리케이션은 바운디드 컨텍스트를 가지거나 아예 가지지 않을 수도 있다.

여기서 눈치채야 할 것은 육각형 아키텍처는 여러 바운디드 컨텍스트를 관리하는 데 도움을 주지 않고 그래야 할 이유도 없다. 대신 DDD에서 영감을 받아 바운디드 컨텍스트를 분리할 수 있는데 한 육각형 내에서는 우리가 원하는 대로 할 수 있기 때문이다.
----
포트와 어댑터가 바운디드 컨텍스트를 분리시키지 않는다면 컨텍스트를 어떻게 분리할 수 있을까? 컨텍스트가 서로 통신하지 않는 간단한 경우에서는 각 컨텍스트에 진입하는 인바운드 포트(컨텍스트의 유스 케이스를 정의)와 해당 컨텍스트가 사용하는 아웃바운드 포트를 정의해서 코드 레벨에서 분리할 수 있다.

각 컨텍스트 별로 인바운드 포트를 정의하지 않고 하나의 넓은 포트를 정의해서 외부에서 들어온 요청을 적절한 컨텍스트로 라우팅할 수도 있지만 이 경우 컨텍스트의 경계가 흐릿해진다. 아웃바운드 포트의 경우는 각 컨텍스트가 각자의 영속성을 가질 수 있도록 컨텍스트 별로 분리하는 것을 권장한다. DB 단 같은 경우는 같은 포트를 사용하는 경우 같은 데이터 모델(테이블)을 사용하면서 쉽게 결합되기 때문에 나중에 분리하기 어려워진다.

그렇지만 아웃바운드 어댑터까지 분리할 필요는 없다. 여러 바운디드 컨텍스트는 같은 데이터베이스의 같은 트랜잭션 내에서 동시에 동작할 수 있기 때문이다. 그렇지만 그 데이터베이스 내에서도 컨텍스트 간 경계는 분리된 데이터베이스 스키마 등의 수단으로 나뉘어야(bounded) 한다.
----
그렇지만 실제로 대부분의 경우 한 컨텍스트는 다른 컨텍스트가 제공하는 기능이 필요하기 때문에 위의 예시처럼 모든 컨텍스트가 독립될 수는 없다. 결제 도메인과 사용자 도메인은 분리된 컨텍스트지만 결제 과정에서 보안을 위해 현재 사용자를 참조하는 예시를 들 수 있다. 이 '현재 사용자'는 결제가 아닌 사용자 도메인에 있기 때문에 결제 도메인 스스로 알아낼 수 없지만 그렇다고 너무 사용자 도메인에 의존하는 것도 경계해야 한다.

그래서 사용자 도메인을 통째로 결제 도메인에서 갖는 것보다는 그냥 사용자의 식별자 정도만 들고있는 게 적절할 수 있다. 사용자는 그 자체로 복잡한 도메인일 수 있지만 결제 도메인의 과정에서는 그냥 아이디와 그 외의 정보들로 구성된 간단한 객체로 취급할 수 있기 때문이다.

그렇지만 '이 사용자가 차단되지 않았는지 확인해야 한다'같은 검증로직이 들어가야 한다면 어떨까? 이 경우 '도메인 이벤트'를 사용할 수 있다. 사용자 관리 컨텍스트에서는 해당 사용자가 차단됐다면 그 내용을 담은 이벤트를 발생시키고 결제 컨텍스트에서는 이를 수신하여 검증로직에서 활용할 수 있다.

또 다른 방법은 애플리케이션 서비스를 orchestrator로 이용하여 사용자 관리와 결제 컨텍스트를 관리하는 것이다. 서비스가 특정 비즈니스 로직을 수행할 때 사용자 관리 컨텍스트에서 먼저 해당 사용자 정보를 가져와서 결제 컨텍스트로 같이 넘기는 식이다. 이 경우 컨텍스트의 인바운드 포트를 컨텍스트가 직접 구현하지 않고 애플리케이션 서비스가 구현하며 서비스는 다른 아웃바운드 포트를 호출하여 필요한 정보를 얻어올 수 있다. 이에 더해서 애플리케이션 서비스는 스스로 트랜잭션 경계처럼 동작하여 여러 유스케이스를 데이터베이스에 실행할 수 있다.
----
But as soon as the codebase reaches a certain size, we should make sure to introduce boundaries between domains, so we can reason about each domain in isolation. If we don't do this, dependencies will creep in, turning our codebase into one of those dreaded "big balls of mud".

Hexagonal Architecture does not help us to manage finer-grained boundaries within our application. Inside our "hexagon", we can do whatever we want.